**JWT (JSON Web Token)** — это открытый стандарт для создания токенов доступа, основанный на формате JSON. Обычно он используется для передачи данных для аутентификации пользователей в клиент-серверных приложениях. Токены создаются сервером, подписываются секретным ключом и передаются юзеру, который в дальнейшем использует их для подтверждения своей личности. То есть они хранятся в куки файлах.

В приложении, где авторизация построена на JWT, чтобы злоумышленник мог получить доступ к контенту пользователя, ему нужно узнать его токен доступа и заменить его в куки файлах.

**Сайт для расшифровки:** https://jwt.io/

![](file:///tmp/lu29189al0fo.tmp/lu29189al0g0_tmp_6a592fb48d01b89b.png)Записываются в куки, там их можно заменить и перезагрузить страничку, таким образом войдя в какую-то другую учетную запись.

Чтобы подделать JWT необходимо знать полезную нагрузку (payload) и ключ (secret). В данном случае надо знать имя пользователя — admin и ключ — Abobik552.

![](file:///tmp/lu29189al0fo.tmp/lu29189al0g0_tmp_5b4ea0d4bb17c4c.png)  


### _Теоретическая информация:_
#### **Структура токена:**

Токен состоит из трех частей: header.payload.signature. Первые две представляют из себя JSON, закодированный при помощи base64. Signature — подпись токена.

- **Header** — заголовок. Он содержит два поля: alg (алгоритм подписи)* и typ (тип токена). В расшифрованном виде он выглядит, например, так:
	{
		"alg": "HS256",
		"typ": "JWT"
	}

	обычно используется HS256 или RS256, но стандарт предполагает и другие алгоритмы шифрования подписи.

	А в зашифрованном виде вот так: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9

  

- **Payload** — полезная нагрузка. Здесь хранится нужная информация о пользователе и токене. Для этого стандартом зарезервированы некоторые ключи, но все они являются необязательными:
	
	iss (issuer) — издатель токена;
	
	sub (subject) — субъект, которому выдан токен;
	
	aud (audience) — получатели, которым предназначается данный токен;
	
	exp (expiration time) — время, когда токен станет невалидным;
	
	nbf (not before) — время, с которого токен должен считаться действительным;
	
	iat (issued at) — время, в которое был выдан токен;
	
	jti (JWT ID) — уникальный идентификатор токена.
	
	Помимо этих ключей можно придумать и добавлять любые другие, которые вам нужны.
	
	Как-то так будет выглядеть полезная нагрузка токена, выписанного на befunny@doubletapp.ai:
	
		{
			"message": "something info",
			"sub": "befunny@doubletapp.ai"
		}
		
		или так:
		
		{
			"exp": 1720258392,
			"username": "admin"
		}
	
	  
	
	Или вот так в base64: eyJtZXNzYWdlIjoiSGVsbG8sIEhhYnIhIiwic3ViIjoiYmVmdW5ueUBkb3VibGV0YXBwLmFpIn0=
	
	Важно! Расшифровать токен может кто угодно (например, на сайте jwt.io). Поэтому ни в коем случае нельзя передавать в нем компрометирующую информацию: чувствительные данные пользователей, пароли и прочее.

- **Signature** — сигнатура токена, создаваемая по следующему принципу:
	
	signature = HMAC_SHA256(secret, base64urlEncoding(header) + '.' + base64urlEncoding(payload))
	
	Закодированные при помощи base64 header и payload сцепляются в одну строку при помощи разделителя — точки. Получившуюся строку кодируют при помощи выбранного алгоритма и секретного ключа.

- **secret** — это ключ для шифровки и проверки подписи. Он генерируется и хранится на сервере и используется для подписи токена при генерации. Также он нужен для проверки токена при получении. Важно обеспечить сохранность, то есть недоступность этого ключа. Причина в том, что с его помощью становится возможно создавать любые токены для вашего приложения, которые будут признаны валидными. Основным требованием к ключу является устойчивость к брутфорсу. Обычно он генерируется в формате hex.

	Конечный токен представляет из себя строку, состоящую из трех ранее описанных частей, соединенных точками. Согласно примеру выше, токен у нас будет такой: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJiZWZ1bm55QGRvdWJsZXRhcHAuYWkiLCJtZXNzYWdlIjoiSGVsbG8sIEhhYnIhIn0.FAMoE435ZafgdICuc6181RsEuR5V1J7dJkzhZRWQk1Y

#### **Почему это работает**

Почему такой формат токена гарантирует нам сохранность данных и невозможность их подмены? Фокус в том, что для проверки подлинности токена достаточно взять из него header и payload, получить по ним signature по алгоритму выше и сравнить сигнатуру с той, что реально присутствует в токене.

Недобросовестный пользователь решил докинуть лишнего в свой токен или поменять юзера, которому он был выдан? Токен будет признан недействительным из-за несовпадения фактической и посчитанной signature, запрос будет отклонен сервером.

  

#### **Простейший сценарий использования JWT-токенов:**

• пользователь регистрируется/логинится в системе, ему выписывается токен;
• этот токен сохраняется на стороне клиента;
• каждый следующий свой запрос клиент делает с заголовком: Authorization: Bearer <token>
• сервер, получая запрос с таким заголовком, проверяет его валидность. И в случае успеха отправляет запрашиваемый контент.

![](file:///tmp/lu29189al0fo.tmp/lu29189al0g0_tmp_e21c4929586b8cf0.png)  

|****Плюсы****|****Минусы****|
| --- | --- |
|Простота<br><br>На стороне сервера не нужно ничего хранить.|Токен выдается один раз и навсегда. Например, если Мэллори перехватит токен Боба, то получит вечный доступ к его данным.  <br>Единственный способ отозвать токен Боба — поменять secret. Но при этом сломаются токены всех остальных пользователей.|


**Access и refresh токены**
Решим проблему с тем, что один токен может использоваться вечно. Для этого изменим схему взаимодействия клиента и сервера. Токены будут двух типов:

**Access Token** — токен доступа к информации, обычно имеет время жизни несколько минут.

**Refresh Token** — токен обновления, по которому можно получить новую пару токенов; срок жизни измеряется днями.


**Сценарий использования**
- пользователь регистрируется и получает пару токенов: access и refresh;
- все свои запросы он сопровождает access-токеном и получает ответ "(как раньше, с обычным jwt-токеном)";
- когда срок жизни access-токена уже истек или начинает подходить к концу, пользователь (или клиентское приложение) отправляет свой refresh-токен серверу, который его отзывает и возвращает новую пару.
    

  

Что будет, если истечет refresh-токен? Пользователю будет нужно пройти авторизацию, чтобы подтвердить свою личность и получить новую пару токенов.

  

При таком подходе у юзера будет доступ к контенту без постоянной потребности в новой аутентификации. Также ущерб от возможного перехвата access-токена злоумышленником будет относительно невелик из-за малого времени жизни токена.

  

Иначе говоря, когда Боб зарегистрируется и получит свою пару токенов, приложением он сможет пользоваться без постоянного ввода логина и пароля. Если же вдруг Мэллори перехватит его access-токен, то ее счастье продлится недолго — время жизни токена скоро истечет, а refresh-токена для обновления у нее нет. О том, что будет, если перехватят refresh-токен, расскажем чуть ниже.