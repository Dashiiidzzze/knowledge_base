
| id  | название | вид блюда | ингред иенты | продолж. готовки | любимое | праздник | рецепт | фото |
| --- | -------- | --------- | ------------ | ---------------- | ------- | -------- | ------ | ---- |
|     |          |           |              |                  |         |          |        |      |
Вот пример структуры базы данных PostgreSQL для хранения таких параметров. Она организована так, чтобы данные были нормализованы, легко расширяемы и оптимальны для запросов.

### 1. Таблицы

#### **Таблица `recipes` (основная информация о рецепте):**
```sql
CREATE TABLE recipes (
    id SERIAL PRIMARY KEY,          -- Уникальный идентификатор рецепта
    name VARCHAR(255) NOT NULL,     -- Название рецепта
    dish_type VARCHAR(100),         -- Вид блюда (например, "завтрак", "ужин")
    cook_time INTERVAL,             -- Продолжительность готовки
    is_favorite BOOLEAN DEFAULT FALSE, -- Флаг "любимый рецепт"
    holiday VARCHAR(100),           -- Праздник, к которому относится (например, "Новый год")
    instructions TEXT,              -- Описание рецепта (шаги готовки)
    photo BYTEA                     -- Фото в виде байтов (опционально)
);
```

#### **Таблица `ingredients` (ингредиенты):**
```sql
CREATE TABLE ingredients (
    id SERIAL PRIMARY KEY,          -- Уникальный идентификатор ингредиента
    name VARCHAR(255) NOT NULL      -- Название ингредиента
);
```

#### **Таблица `recipe_ingredients` (связь между рецептами и ингредиентами):**
```sql
CREATE TABLE recipe_ingredients (
    id SERIAL PRIMARY KEY,          -- Уникальный идентификатор
    recipe_id INT REFERENCES recipes(id) ON DELETE CASCADE, -- Рецепт
    ingredient_id INT REFERENCES ingredients(id) ON DELETE CASCADE, -- Ингредиент
    quantity VARCHAR(100)           -- Количество ингредиента (например, "200 г", "1 ст. ложка")
);
```

### 2. Пример добавления данных

#### **Добавление рецепта:**
```sql
INSERT INTO recipes (name, dish_type, cook_time, is_favorite, holiday, instructions) 
VALUES 
('Оливье', 'Салат', '00:30:00', TRUE, 'Новый год', 'Нарезать ингредиенты, смешать с майонезом');
```

#### **Добавление ингредиентов:**
```sql
INSERT INTO ingredients (name) VALUES 
('Картофель'),
('Морковь'),
('Горошек зеленый'),
('Колбаса'),
('Майонез');
```

#### **Связывание рецепта с ингредиентами:**
```sql
INSERT INTO recipe_ingredients (recipe_id, ingredient_id, quantity) 
VALUES 
(1, 1, '3 шт'),
(1, 2, '2 шт'),
(1, 3, '200 г'),
(1, 4, '300 г'),
(1, 5, '100 г');
```

### 3. Пример запросов

#### Получить полный список рецептов с ингредиентами:
```sql
SELECT 
    r.id AS recipe_id,
    r.name AS recipe_name,
    r.dish_type,
    r.cook_time,
    r.is_favorite,
    r.holiday,
    r.instructions,
    i.name AS ingredient_name,
    ri.quantity
FROM recipes r
LEFT JOIN recipe_ingredients ri ON r.id = ri.recipe_id
LEFT JOIN ingredients i ON ri.ingredient_id = i.id
ORDER BY r.id;
```

#### Найти все рецепты с ингредиентом "Картофель":
```sql
SELECT r.id, r.name
FROM recipes r
JOIN recipe_ingredients ri ON r.id = ri.recipe_id
JOIN ingredients i ON ri.ingredient_id = i.id
WHERE i.name = 'Картофель';
```

#### Получить любимые рецепты:
```sql
SELECT id, name, dish_type, cook_time 
FROM recipes
WHERE is_favorite = TRUE;
```

### 4. Особенности
1. **Фото**: Хранится в виде байтов в столбце `photo`. Для работы с изображениями можно использовать инструменты PostgreSQL (например, `pg_largeobject`) или хранить ссылки на файлы, если они будут сохраняться на диске.
2. **Праздники**: Для предсказуемых значений можно создать отдельную таблицу праздников, чтобы связать их через внешний ключ.
3. **Ингредиенты**: Нормализация ингредиентов через таблицу `ingredients` позволит избегать дублирования и упрощает их управление.
4. **Удобство запросов**: Для ускорения поиска можно добавить индексы на поля, часто используемые в запросах (например, `is_favorite`, `dish_type`).

Это позволит вам легко добавлять новые параметры и делать запросы для аналитики (например, самых популярных блюд) или работы с интерфейсом.




# Добавление индексов:
**Индексы** в базах данных — это структуры данных, которые хранятся отдельно от основной таблицы и позволяют ускорять доступ к данным. Они работают как указатели или словари, облегчая поиск нужных строк в таблице без полного её сканирования.

---

### Зачем нужны индексы?
Когда вы делаете запрос, например:
```sql
SELECT * FROM recipes WHERE is_favorite = TRUE;
```
Если на поле `is_favorite` нет индекса, база данных должна просмотреть **все строки таблицы** (`Sequential Scan`), чтобы найти подходящие записи. Это может быть медленным, особенно если в таблице много данных.

С индексом база данных вместо сканирования всей таблицы находит подходящие строки значительно быстрее, так как в индексе хранится упорядоченная информация для поиска.

---

### Как работают индексы
Индексы организуют данные так, чтобы их было легко искать. Вот несколько способов, как это делается:
1. **B-дерево (B-tree)**: стандартный индекс, подходит для поиска по точным значениям или диапазонам.
   - Пример: Найти рецепты с продолжительностью готовки меньше 30 минут.
2. **GIN (Generalized Inverted Index)**: используется для поиска по полнотекстовым данным.
   - Пример: Найти рецепты, где в инструкции упоминается слово "взбить".
3. **Hash**: используется для быстрого поиска по точным совпадениям.
   - Пример: Найти рецепт с определённым ID.
4. **GiST (Generalized Search Tree)**: полезен для сложных запросов, например, для геометрических данных.

---

### Типы индексов в PostgreSQL
1. **Уникальные индексы (`UNIQUE`)**:
   - Гарантируют, что значения в указанном столбце (или столбцах) будут уникальными.
   ```sql
   CREATE UNIQUE INDEX idx_recipes_id ON recipes (id);
   ```

2. **Стандартные индексы (B-Tree)**:
   - Используются для поиска по значениям и диапазонам.
   ```sql
   CREATE INDEX idx_recipes_dish_type ON recipes (dish_type);
   ```

3. **Полнотекстовые индексы (GIN)**:
   - Для быстрого поиска текста.
   ```sql
   CREATE INDEX idx_recipes_instructions ON recipes USING gin(to_tsvector('russian', instructions));
   ```

4. **Составные индексы**:
   - Создаются на нескольких столбцах, если запросы часто используют их вместе.
   ```sql
   CREATE INDEX idx_recipe_ingredients_recipe_id_ingredient_id 
   ON recipe_ingredients (recipe_id, ingredient_id);
   ```

---

### Пример из жизни
Представьте библиотеку, где книги просто лежат в огромной стопке (таблица без индексов). Чтобы найти конкретную книгу, нужно перебирать все по очереди. Если книги отсортированы по названию или с указателями (индексами), нужную книгу можно найти сразу.

---

### Плюсы индексов
- Ускоряют поиск данных.
- Улучшают производительность соединений (`JOIN`).
- Полезны для фильтрации (`WHERE`), сортировки (`ORDER BY`) и группировки (`GROUP BY`).

---

### Минусы индексов
1. **Увеличение объёма памяти**: индексы занимают место на диске.
2. **Замедление операций записи**: добавление, обновление или удаление данных требует обновления индексов.
3. **Не все запросы ускоряются**: например, индексы не помогают, если в фильтре условия на множество значений или операции над данными (например, `LOWER(name)` без создания функционального индекса).

---

### Когда использовать индексы
- Если таблица большая (более нескольких тысяч строк).
- Если запросы часто используют одни и те же поля в фильтрах или сортировках.
- Если запросы замедляются при росте объёма данных.

Индексы — мощный инструмент, но их нужно использовать с умом, чтобы избежать избыточности и ненужной нагрузки на систему.

Для ускорения поиска в PostgreSQL можно добавить **индексы** на столбцы, которые часто используются в фильтрах `WHERE`, `JOIN`, `ORDER BY` или при сортировке.

### Пример добавления индексов
1. **Создание индекса на поле `is_favorite`** (для быстрого поиска любимых рецептов):
   ```sql
   CREATE INDEX idx_recipes_is_favorite ON recipes (is_favorite);
   ```

2. **Индекс на поле `dish_type`** (для фильтрации по виду блюда):
   ```sql
   CREATE INDEX idx_recipes_dish_type ON recipes (dish_type);
   ```

3. **Индекс на поле `holiday`** (для быстрого поиска по праздникам):
   ```sql
   CREATE INDEX idx_recipes_holiday ON recipes (holiday);
   ```

4. **Индекс на поле `name` в таблице `ingredients`** (для поиска ингредиентов по имени):
   ```sql
   CREATE INDEX idx_ingredients_name ON ingredients (name);
   ```

5. **Композитный индекс** на поля `recipe_id` и `ingredient_id` в таблице `recipe_ingredients` (для ускорения соединения рецептов с ингредиентами):
   ```sql
   CREATE INDEX idx_recipe_ingredients_recipe_id_ingredient_id 
   ON recipe_ingredients (recipe_id, ingredient_id);
   ```

6. **Полнотекстовый индекс** на описание рецепта `instructions` (для поиска по тексту):
   ```sql
   CREATE INDEX idx_recipes_instructions_fulltext 
   ON recipes USING gin(to_tsvector('russian', instructions));
   ```

---

### Когда нужно добавлять индексы
- Если поле часто используется в фильтрах, например, `WHERE dish_type = 'Салат'`.
- Если поле участвует в соединениях таблиц `JOIN`.
- Если данные сортируются по этому столбцу (например, `ORDER BY cook_time`).

### Как проверить, нужен ли индекс
Используйте команду `EXPLAIN` для анализа выполнения запроса:
```sql
EXPLAIN ANALYZE 
SELECT * 
FROM recipes 
WHERE is_favorite = TRUE;
```
Если запрос выполняется медленно и PostgreSQL делает **полное сканирование таблицы** (`Seq Scan`), то индекс может значительно ускорить процесс.

---

### Как удалить ненужный индекс
Если вы обнаружите, что индекс больше не нужен, его можно удалить:
```sql
DROP INDEX idx_recipes_is_favorite;
```

---

### Предостережения
- **Индексы увеличивают время записи в таблицу**, так как при добавлении или обновлении данных нужно обновлять и индексы.
- Не стоит добавлять индексы на каждое поле — сосредоточьтесь на наиболее важных для запросов.