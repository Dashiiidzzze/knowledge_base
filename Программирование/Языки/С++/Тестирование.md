Тестирование кода - это процесс анализа и проверки исходного кода программного обеспечения с целью обнаружения и исправления ошибок, улучшения структуры кода и повышения его эффективности.

### Виды тестов:
- Блочные (Unit testing) - тестирование одного модуля в изоляции
- Интегрированное (INtegration testing) - тестирование группы взаимодействующих модулей
- Системное (Systrem testing) - тестирование системы в целом

### Код юнит-тестов:
```C++
#define BOOST_TEST_MODULE MassivTest
#include <boost/test/included/unit_test.hpp>
#include "header.h"

// Открываем тестовый набор
BOOST_AUTO_TEST_SUITE(MassivTestSuite)

// Тест на добавление элемента
BOOST_AUTO_TEST_CASE(TestAdd) {
    Massiv myArray(5, 50);
    myArray.Add("test");
    BOOST_CHECK_EQUAL(myArray.Length(), 1);
    BOOST_CHECK_EQUAL(myArray.Get(0), "test");
}

// Тест получения элемента
BOOST_AUTO_TEST_CASE(GetTest) {
	Massiv m(3, 50);
	m.Add("first");
	m.Add("second");
	BOOST_CHECK_EQUAL(m.Get(0), "first");
	BOOST_CHECK_EQUAL(m.Get(1), "second");
	// Проверяем исключение на некорректный индекс
	BOOST_CHECK_THROW(m.Get(2), std::runtime_error);
	BOOST_CHECK_THROW(m.Get(-1), std::runtime_error);
}

// Закрываем тестовый набор
BOOST_AUTO_TEST_SUITE_END()

```

### Команда запуска тестов:
```
g++ -o test_massiv test.cpp dasMap.cpp ../1zadanie/massiv.cpp ../1zadanie/metodFile.cpp -I /path/to/boost/include -L /path/to/boost/lib -lboost_unit_test_framework
```

### Команды для генерации HTML отчета:
```
# Компиляция с флагами профилирования
g++ -fprofile-arcs -ftest-coverage -o main main.cpp massiv.cpp -lboost_unit_test_framework

# Запуск тестов
./main

# Сбор данных покрытия
lcov --capture --directory . --output-file coverage.info

# Удаление ненужных файлов из отчета
lcov --remove coverage.info '/usr/*' --output-file filtered_coverage.info

# Генерация HTML-отчета
genhtml filtered_coverage.info --output-directory coverage_report

```

## Бенчмарки
```C++
// Бенчмарк для Push
BOOST_AUTO_TEST_CASE(QueuePushBenchmark) {
Queue queue;
string value = "test_value";
size_t iterations = 100000;
  
auto start = chrono::high_resolution_clock::now();
for (size_t i = 0; i < iterations; ++i) {
	queue.Push(value);
}
auto end = chrono::high_resolution_clock::now();

auto duration = chrono::duration_cast<chrono::milliseconds>(end - start).count();
BOOST_TEST_MESSAGE("Push benchmark: " << duration << " ms for " << iterations << " iterations");
}
```

запуск: `./test_queue --log_level=all`
либо вместо `BOOST_TEST_MESSAGE` писать `cout`